# SEC-001: Implement Encryption at Rest

## üìã Task Overview
**ID:** SEC-001
**Title:** Implement encryption at rest for all checkpoint data
**Status:** üî¥ RED - MISSING (Security Hole)
**Priority:** P0 - SECURITY BLOCKER
**Category:** Security
**Estimated Days:** 1 week
**Phase:** Critical Security Fix
**Dependencies:** None
**Created:** 2025-10-01

## üö® CRITICAL SECURITY ISSUE
**All checkpoint data is stored unencrypted. This is a CRITICAL SECURITY VIOLATION.**

Without encryption at rest:
- ‚ùå **Data breach risk** - Checkpoint data exposed if storage compromised
- ‚ùå **Compliance violations** - Fails GDPR, SOC2, HIPAA, PCI-DSS
- ‚ùå **Legal liability** - Potential lawsuits from data exposure
- ‚ùå **Unsuitable for production** with ANY sensitive data

## üéØ Objective
Implement AES-256-GCM encryption for all checkpoint data at rest across all persistence backends (Memory, SQLite, PostgreSQL, Redis, S3). Ensure zero unencrypted data persists to storage.

## üìù Technical Requirements

### Encryption Standards
- **Algorithm**: AES-256-GCM (authenticated encryption)
- **Key Management**: Environment-based initially, Vault integration later
- **Key Rotation**: Support for key versioning and rotation
- **Performance**: < 5% overhead for typical checkpoints
- **Compliance**: FIPS 140-2 compliant implementation

## ‚úÖ Acceptance Criteria

### üî¥ RED Phase - Write Failing Tests
- [ ] **Test encryption on save** - Verify data is encrypted before storage
- [ ] **Test decryption on load** - Verify data is decrypted correctly
- [ ] **Test key rotation** - Verify old data readable with new keys
- [ ] **Test encryption across backends** - All backends must encrypt
- [ ] **Test performance impact** - Ensure < 5% overhead
- [ ] **Test tampering detection** - GCM authentication catches modifications

### üü° YELLOW Phase - Minimal Implementation
- [ ] **Add encryption trait** - Define encryption interface
- [ ] **Implement AES-256-GCM** - Core encryption/decryption
- [ ] **Integrate with checkpointers** - All backends encrypt
- [ ] **Basic key management** - Environment variable for key
- [ ] **All tests passing** - Basic encryption working

### üü¢ GREEN Phase - Production Hardening
- [ ] **Key rotation support** - Version keys, migrate data
- [ ] **Key derivation (KDF)** - PBKDF2 or Argon2 for key strengthening
- [ ] **Secure key storage** - Never log keys, secure memory handling
- [ ] **Performance optimization** - Streaming encryption for large data
- [ ] **Audit logging** - Log encryption operations (not keys!)
- [ ] **Vault integration ready** - Prepare for external key management

## üîß Technical Implementation

### Dependencies
```toml
# Cargo.toml additions
aes-gcm = "0.10"          # AES-GCM encryption
argon2 = "0.5"            # Key derivation function
zeroize = "1.6"           # Secure memory clearing
rand = "0.8"              # Secure random for IVs
base64 = "0.21"           # Encoding encrypted data
```

### Core Implementation
```rust
// src/checkpoint/encryption.rs

use aes_gcm::{
    aead::{Aead, KeyInit, OsRng},
    Aes256Gcm, Nonce, Key
};
use zeroize::Zeroizing;

pub struct EncryptionManager {
    cipher: Aes256Gcm,
    key_version: u32,
}

impl EncryptionManager {
    pub fn new(key: Zeroizing<Vec<u8>>) -> Result<Self> {
        let key = Key::<Aes256Gcm>::from_slice(&key);
        let cipher = Aes256Gcm::new(key);

        Ok(Self {
            cipher,
            key_version: 1,
        })
    }

    pub fn encrypt(&self, plaintext: &[u8]) -> Result<EncryptedData> {
        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);
        let ciphertext = self.cipher.encrypt(&nonce, plaintext)?;

        Ok(EncryptedData {
            version: self.key_version,
            nonce: nonce.to_vec(),
            ciphertext,
        })
    }

    pub fn decrypt(&self, encrypted: &EncryptedData) -> Result<Vec<u8>> {
        // Check key version for rotation support
        if encrypted.version != self.key_version {
            return self.decrypt_with_old_key(encrypted);
        }

        let nonce = Nonce::from_slice(&encrypted.nonce);
        let plaintext = self.cipher.decrypt(nonce, encrypted.ciphertext.as_ref())?;

        Ok(plaintext)
    }
}

// Integration with checkpointers
impl Checkpointer for EncryptedCheckpointer<T> {
    async fn save(&self, checkpoint: &Checkpoint) -> Result<()> {
        // Serialize checkpoint
        let data = serde_json::to_vec(checkpoint)?;

        // Encrypt data
        let encrypted = self.encryption_manager.encrypt(&data)?;

        // Store encrypted data
        self.inner.save_raw(&encrypted).await?;

        Ok(())
    }

    async fn load(&self, thread_id: &str) -> Result<Option<Checkpoint>> {
        // Load encrypted data
        let encrypted = self.inner.load_raw(thread_id).await?;

        // Decrypt data
        let data = self.encryption_manager.decrypt(&encrypted)?;

        // Deserialize checkpoint
        let checkpoint = serde_json::from_slice(&data)?;

        Ok(Some(checkpoint))
    }
}
```

### Key Management
```rust
// src/checkpoint/key_management.rs

pub struct KeyManager {
    current_key: Zeroizing<Vec<u8>>,
    old_keys: Vec<(u32, Zeroizing<Vec<u8>>)>, // For rotation
}

impl KeyManager {
    pub fn from_env() -> Result<Self> {
        let key_str = std::env::var("CHECKPOINT_ENCRYPTION_KEY")
            .map_err(|_| "CHECKPOINT_ENCRYPTION_KEY not set")?;

        // Derive key using KDF
        let key = Self::derive_key(&key_str)?;

        Ok(Self {
            current_key: Zeroizing::new(key),
            old_keys: Vec::new(),
        })
    }

    fn derive_key(password: &str) -> Result<Vec<u8>> {
        // Use Argon2 for key derivation
        let salt = b"langgraph-checkpoint-salt"; // Should be random in production
        let config = argon2::Config::default();
        let hash = argon2::hash_raw(password.as_bytes(), salt, &config)?;

        Ok(hash)
    }

    pub fn rotate_key(&mut self, new_key: Zeroizing<Vec<u8>>) {
        // Keep old key for decrypting old data
        let old = std::mem::replace(&mut self.current_key, new_key);
        self.old_keys.push((self.version, old));
        self.version += 1;
    }
}
```

## ‚ö†Ô∏è Security Considerations

### What to Encrypt
- ‚úÖ **All checkpoint data** - Full state serialization
- ‚úÖ **Metadata** - Thread IDs, timestamps if sensitive
- ‚úÖ **Backup data** - All backups must be encrypted
- ‚úÖ **Temporary files** - Any disk spillover

### What NOT to Encrypt
- ‚ùå **Checkpoint IDs** - Needed for lookup
- ‚ùå **Non-sensitive metadata** - Performance metrics
- ‚ùå **System logs** - But never log keys or data

### Security Best Practices
1. **Never log encryption keys**
2. **Use secure memory (zeroize) for keys**
3. **Generate random IVs for each encryption**
4. **Implement key rotation from day one**
5. **Use authenticated encryption (GCM mode)**
6. **Secure key storage (environment ‚Üí Vault)**

## üìä Performance Impact

### Expected Overhead
- **Small checkpoints (<1KB)**: ~2-3ms additional latency
- **Medium checkpoints (1-10KB)**: ~5-10ms additional latency
- **Large checkpoints (>10KB)**: ~2-5% overhead
- **Memory usage**: Minimal (cipher state only)

### Optimization Strategies
- Stream encryption for large checkpoints
- Async encryption in background
- Connection pooling for encrypted backends
- Caching decrypted data with TTL

## üß™ Testing Requirements

### Security Tests
```rust
#[test]
fn test_encryption_at_rest() {
    // Create checkpoint
    // Save with encryption
    // Read raw from storage
    // Verify data is encrypted (not readable)
    // Load through checkpointer
    // Verify decrypted correctly
}

#[test]
fn test_tampering_detection() {
    // Encrypt data
    // Modify ciphertext
    // Attempt decrypt
    // Verify authentication fails
}

#[test]
fn test_key_rotation() {
    // Encrypt with key v1
    // Rotate to key v2
    // Encrypt new data with v2
    // Verify old data still readable
    // Verify new data uses v2
}
```

## üìÖ Implementation Timeline
- **Day 1**: Write comprehensive tests (RED phase)
- **Day 2-3**: Implement core encryption (YELLOW phase)
- **Day 4**: Integrate with all checkpointers
- **Day 5**: Key management and rotation
- **Day 6**: Performance optimization
- **Day 7**: Security audit and hardening

## üö® Compliance Requirements

Must meet:
- **GDPR**: Data protection by design
- **SOC2**: Encryption at rest controls
- **HIPAA**: If handling health data
- **PCI-DSS**: If handling payment data
- **FIPS 140-2**: Government compliance

## üìù Future Enhancements
- HashiCorp Vault integration
- Hardware security module (HSM) support
- Multi-master key encryption
- Encrypted search capabilities
- Homomorphic encryption for processing encrypted data

## ‚ö†Ô∏è Deployment Checklist
- [ ] Generate strong encryption key
- [ ] Set CHECKPOINT_ENCRYPTION_KEY environment variable
- [ ] Never commit keys to version control
- [ ] Set up key rotation schedule
- [ ] Document key recovery procedures
- [ ] Test disaster recovery with encryption

## üî¥ BLOCKER STATUS
**This MUST be implemented before ANY production deployment with sensitive data.**