# MSG-001: MessageGraph Core Structure

## 📋 Task Overview
**ID:** MSG-001  
**Title:** MessageGraph core structure  
**Status:** 🔴 TODO  
**Priority:** P0 (Critical)  
**Category:** MessageGraph  
**Estimated Days:** 3  
**Phase:** Phase 1 - Critical Features  

## 🎯 Objective
Implement the core MessageGraph structure that enables message-based workflows, matching Python LangGraph's MessageGraph functionality for conversational AI applications.

## 📝 Description
MessageGraph is a specialized graph type optimized for message-passing and conversational workflows. It provides:
- Message-based state management
- Conversation history tracking
- Message routing based on content
- Support for multi-turn interactions

## ✅ Acceptance Criteria
- [ ] MessageGraph struct with builder pattern
- [ ] Message types (User, Assistant, System, Tool)
- [ ] Message history management
- [ ] Message-based routing
- [ ] Integration with existing StateGraph
- [ ] Serialization/deserialization support
- [ ] Thread-safe message operations
- [ ] Support for message metadata
- [ ] Comprehensive tests

## 🔧 Technical Requirements

### Core Components to Implement
```rust
// src/graph/message_graph.rs
use serde::{Serialize, Deserialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageRole {
    User,
    Assistant,
    System,
    Tool,
    Function,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub id: Uuid,
    pub role: MessageRole,
    pub content: String,
    pub metadata: HashMap<String, Value>,
    pub timestamp: SystemTime,
    pub parent_id: Option<Uuid>,
}

pub struct MessageGraph {
    graph: StateGraph,
    messages: Arc<RwLock<Vec<Message>>>,
    message_handlers: HashMap<MessageRole, Box<dyn MessageHandler>>,
}

pub trait MessageHandler: Send + Sync {
    async fn handle(&self, message: &Message, context: &mut MessageContext) -> Result<Response>;
}

pub struct MessageContext {
    pub history: Vec<Message>,
    pub state: StateData,
    pub graph: Arc<MessageGraph>,
}

impl MessageGraph {
    pub fn builder(name: &str) -> MessageGraphBuilder {
        MessageGraphBuilder::new(name)
    }
    
    pub async fn add_message(&self, message: Message) -> Result<()>;
    pub async fn process_message(&self, message: Message) -> Result<Response>;
    pub async fn get_conversation(&self) -> Vec<Message>;
    pub async fn clear_history(&self) -> Result<()>;
}
```

### Python API Compatibility
```python
# Python LangGraph
from langgraph.graph import MessageGraph

graph = MessageGraph()
graph.add_node("chat", chat_function)
graph.add_edge("chat", "end")
```

```rust
// Rust equivalent
use langgraph::graph::MessageGraph;

let graph = MessageGraph::builder("chat_workflow")
    .add_node("chat", chat_function)
    .add_edge("chat", "end")
    .build()?;
```

## 🚦 Implementation Plan (Traffic-Light)

### 🔴 RED Phase - Tests First (Day 1)
```rust
#[tokio::test]
async fn test_message_graph_conversation() {
    let graph = MessageGraph::builder("test")
        .add_node("respond", respond_handler)
        .build()?;
    
    let user_msg = Message::user("Hello");
    let response = graph.process_message(user_msg).await?;
    
    assert_eq!(response.role, MessageRole::Assistant);
    assert!(!response.content.is_empty());
    
    let history = graph.get_conversation().await;
    assert_eq!(history.len(), 2);
}
```

### 🟡 YELLOW Phase - Minimal Implementation (Day 2)
- Basic MessageGraph structure
- Message types and storage
- Simple message processing
- Integration with StateGraph

### 🟢 GREEN Phase - Production Ready (Day 3)
- Advanced routing strategies
- Message threading
- Metadata handling
- Performance optimization
- Message persistence
- Streaming responses
- Error recovery

## 📊 Success Metrics
- < 1ms message append time
- Support for 10K+ message history
- Zero message loss
- Thread-safe operations
- Python compatibility tests passing

## 🔗 Dependencies
- StateGraph implementation
- Serialization (serde)
- Async runtime (tokio)

## ⚠️ Risks & Mitigations
| Risk | Mitigation |
|------|------------|
| Memory growth with history | Implement pagination/pruning |
| Message ordering issues | Use timestamps and locks |
| Serialization overhead | Use efficient formats |

## 📚 References
- [Python MessageGraph](https://github.com/langchain-ai/langgraph/blob/main/langgraph/graph/message.py)
- [Conversation Design Patterns](https://docs.anthropic.com/patterns)

## 🎯 Definition of Done
- [ ] All acceptance criteria met
- [ ] Tests passing (unit and integration)
- [ ] Python compatibility validated
- [ ] Documentation complete
- [ ] Example conversation app working
- [ ] Performance benchmarked