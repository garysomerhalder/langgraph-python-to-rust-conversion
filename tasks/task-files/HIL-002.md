# HIL-002: Breakpoint management system

## 📋 Task Overview
**ID:** HIL-002
**Title:** Breakpoint management system
**Status:** 🟡 IN_PROGRESS
**Priority:** P0 (Critical)
**Category:** Human-in-the-Loop
**Estimated Days:** 2
**Phase:** Phase 1 - Critical Features

## 🎯 Objective
Implement a comprehensive breakpoint management system that allows setting, removing, and managing breakpoints at specific nodes in the graph execution flow.

## 📝 Description
Breakpoints are essential for debugging and human-in-the-loop workflows. They allow developers to:
- Pause execution at specific points
- Inspect state before/after nodes
- Conditionally break based on state values
- Resume, step-through, or abort execution

## ✅ Acceptance Criteria
- [ ] Can set breakpoints on specific nodes
- [ ] Can set conditional breakpoints based on state
- [ ] Can list all active breakpoints
- [ ] Can remove individual or all breakpoints
- [ ] Execution pauses at breakpoints
- [ ] Can inspect state at breakpoint
- [ ] Can resume, step, or abort from breakpoint
- [ ] Thread-safe breakpoint management
- [ ] Integration with InterruptManager
- [ ] Persistence of breakpoint configuration

## 🔧 Technical Requirements

### Core Components to Implement
```rust
// src/engine/breakpoint.rs
pub struct Breakpoint {
    pub id: Uuid,
    pub node_id: String,
    pub condition: Option<Box<dyn Fn(&StateData) -> bool + Send + Sync>>,
    pub enabled: bool,
    pub hit_count: usize,
    pub created_at: SystemTime,
}

pub struct BreakpointManager {
    breakpoints: DashMap<String, Vec<Breakpoint>>,
    hit_history: Arc<RwLock<Vec<BreakpointHit>>>,
    callbacks: Arc<RwLock<Vec<BreakpointCallback>>>,
}

pub enum BreakpointAction {
    Continue,
    StepOver,
    StepInto,
    StepOut,
    Abort(String),
}

impl BreakpointManager {
    pub fn set_breakpoint(&self, node_id: String, condition: Option<BreakpointCondition>) -> Uuid;
    pub fn remove_breakpoint(&self, id: Uuid) -> bool;
    pub fn list_breakpoints(&self) -> Vec<Breakpoint>;
    pub fn clear_all_breakpoints(&self);
    pub fn is_breakpoint(&self, node_id: &str, state: &StateData) -> bool;
    pub async fn handle_breakpoint(&self, node_id: &str, state: StateData) -> BreakpointAction;
}
```

### Integration Points
1. **ExecutionEngine** - Check for breakpoints during node execution
2. **InterruptManager** - Coordinate with interrupt system
3. **GraphTraverser** - Support step operations
4. **StateInspector** - Provide state inspection at breakpoints

## 🚦 Implementation Plan

### 🔴 RED Phase - Tests First
- Write tests for setting/removing breakpoints
- Test conditional breakpoint evaluation
- Test execution pausing at breakpoints
- Test step operations

### 🟡 YELLOW Phase - Minimal Implementation
- Basic breakpoint structure
- Simple breakpoint manager
- Integration with execution engine
- Basic pause/resume functionality

### 🟢 GREEN Phase - Production Ready
- Conditional breakpoints with complex expressions
- Step operations (over, into, out)
- Breakpoint persistence
- Performance optimization
- Comprehensive debugging interface

## 📊 Success Metrics
- Zero performance impact when no breakpoints set
- < 1ms breakpoint evaluation time
- Thread-safe concurrent breakpoint operations
- All debugging operations non-blocking

## 🔗 Dependencies
- HIL-001 (Interrupt mechanism) - DONE
- ExecutionEngine
- StateManager

## 🎯 Definition of Done
- [ ] All acceptance criteria met
- [ ] Tests passing (RED → YELLOW → GREEN)
- [ ] Code reviewed and approved
- [ ] Documentation updated
- [ ] Example added showing breakpoint usage
- [ ] Performance benchmarked