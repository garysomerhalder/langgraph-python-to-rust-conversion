# SEC-002: Add Authentication and Authorization

## üìã Task Overview
**ID:** SEC-002
**Title:** Implement authentication and authorization for multi-tenant security
**Status:** üî¥ RED - MISSING (Security Hole)
**Priority:** P0 - SECURITY BLOCKER
**Category:** Security
**Estimated Days:** 1-2 weeks
**Phase:** Critical Security Fix
**Dependencies:** None
**Created:** 2025-10-01

## üö® CRITICAL SECURITY ISSUE
**No authentication or authorization exists. Anyone can execute anything.**

Security violations:
- ‚ùå **No access control** - All operations unrestricted
- ‚ùå **No user identity** - Cannot track who does what
- ‚ùå **No audit trail** - No accountability
- ‚ùå **Multi-tenant risk** - Data leakage between tenants
- ‚ùå **Privilege escalation** - No permission boundaries

## üéØ Objective
Implement comprehensive authentication and authorization system with:
- API key authentication for service accounts
- JWT tokens for user sessions
- Role-Based Access Control (RBAC)
- Multi-tenant isolation
- Audit logging for compliance

## üìù Technical Requirements

### Authentication Methods
1. **API Keys** - Service-to-service authentication
2. **JWT Tokens** - User session management
3. **OAuth2** - Third-party integrations (future)
4. **mTLS** - Certificate-based for internal services

### Authorization Model
- **RBAC** - Role-based permissions
- **Resource-based** - Per-checkpoint/graph permissions
- **Tenant isolation** - Complete data segregation
- **Principle of least privilege** - Default deny

## ‚úÖ Acceptance Criteria

### üî¥ RED Phase - Write Failing Tests
- [ ] **Test authentication required** - Unauthenticated requests rejected
- [ ] **Test API key validation** - Invalid keys rejected
- [ ] **Test JWT verification** - Token validation and expiry
- [ ] **Test RBAC enforcement** - Permission checks work
- [ ] **Test tenant isolation** - No cross-tenant access
- [ ] **Test audit logging** - All operations logged

### üü° YELLOW Phase - Minimal Implementation
- [ ] **Authentication middleware** - Intercept all requests
- [ ] **API key validation** - Basic key checking
- [ ] **Simple RBAC** - Admin/user/readonly roles
- [ ] **Tenant context** - Track tenant per request
- [ ] **Basic audit log** - Log operations to file

### üü¢ GREEN Phase - Production Hardening
- [ ] **JWT with refresh tokens** - Secure session management
- [ ] **Rate limiting** - Prevent brute force
- [ ] **IP allowlisting** - Network-level security
- [ ] **Advanced RBAC** - Custom roles and permissions
- [ ] **Structured audit logs** - Compliance-ready logging
- [ ] **Security headers** - CORS, CSP, etc.
- [ ] **API key rotation** - Regular key refresh

## üîß Technical Implementation

### Dependencies
```toml
# Cargo.toml additions
jsonwebtoken = "9.0"        # JWT token handling
argon2 = "0.5"             # Password hashing
axum-auth = "0.4"          # Auth middleware for Axum
tower = "0.4"              # Middleware framework
uuid = "1.18"              # User/tenant IDs
chrono = "0.4"             # Token expiry
```

### Core Implementation
```rust
// src/auth/authentication.rs

use jsonwebtoken::{encode, decode, Header, Validation, EncodingKey, DecodingKey};
use axum::extract::{Request, State};
use axum::middleware::Next;
use axum::response::Response;

#[derive(Debug, Clone)]
pub struct AuthContext {
    pub user_id: String,
    pub tenant_id: String,
    pub roles: Vec<String>,
    pub permissions: HashSet<Permission>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String,        // User ID
    pub tenant: String,     // Tenant ID
    pub roles: Vec<String>,
    pub exp: usize,         // Expiry
    pub iat: usize,         // Issued at
}

pub struct AuthMiddleware {
    jwt_secret: String,
    api_keys: HashMap<String, ApiKeyInfo>,
}

impl AuthMiddleware {
    pub async fn authenticate(
        State(auth): State<Arc<AuthMiddleware>>,
        mut req: Request,
        next: Next,
    ) -> Result<Response, AuthError> {
        // Extract auth header
        let auth_header = req.headers()
            .get("Authorization")
            .ok_or(AuthError::MissingCredentials)?;

        let auth_str = auth_header.to_str()
            .map_err(|_| AuthError::InvalidCredentials)?;

        // Check auth type
        let auth_context = if auth_str.starts_with("Bearer ") {
            // JWT authentication
            let token = &auth_str[7..];
            auth.validate_jwt(token).await?
        } else if auth_str.starts_with("ApiKey ") {
            // API key authentication
            let key = &auth_str[7..];
            auth.validate_api_key(key).await?
        } else {
            return Err(AuthError::InvalidAuthScheme);
        };

        // Add auth context to request
        req.extensions_mut().insert(auth_context);

        Ok(next.run(req).await)
    }

    async fn validate_jwt(&self, token: &str) -> Result<AuthContext> {
        let validation = Validation::default();
        let key = DecodingKey::from_secret(self.jwt_secret.as_bytes());

        let token_data = decode::<Claims>(token, &key, &validation)
            .map_err(|_| AuthError::InvalidToken)?;

        // Build auth context from claims
        let permissions = self.load_permissions(&token_data.claims.roles).await?;

        Ok(AuthContext {
            user_id: token_data.claims.sub,
            tenant_id: token_data.claims.tenant,
            roles: token_data.claims.roles,
            permissions,
        })
    }

    async fn validate_api_key(&self, key: &str) -> Result<AuthContext> {
        let key_info = self.api_keys.get(key)
            .ok_or(AuthError::InvalidApiKey)?;

        // Check if key is active and not expired
        if !key_info.is_active || key_info.expires_at < Utc::now() {
            return Err(AuthError::ExpiredApiKey);
        }

        Ok(AuthContext {
            user_id: key_info.user_id.clone(),
            tenant_id: key_info.tenant_id.clone(),
            roles: key_info.roles.clone(),
            permissions: key_info.permissions.clone(),
        })
    }
}
```

### Authorization Implementation
```rust
// src/auth/authorization.rs

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Permission {
    // Checkpoint permissions
    CheckpointCreate,
    CheckpointRead,
    CheckpointUpdate,
    CheckpointDelete,

    // Graph permissions
    GraphExecute,
    GraphCreate,
    GraphRead,
    GraphUpdate,
    GraphDelete,

    // Admin permissions
    UserManage,
    TenantManage,
    SystemAdmin,
}

pub struct AuthorizationService {
    role_permissions: HashMap<String, HashSet<Permission>>,
}

impl AuthorizationService {
    pub fn check_permission(
        &self,
        auth: &AuthContext,
        permission: Permission,
    ) -> Result<(), AuthError> {
        // Check if user has required permission
        if !auth.permissions.contains(&permission) {
            return Err(AuthError::InsufficientPermissions);
        }

        Ok(())
    }

    pub fn check_resource_access(
        &self,
        auth: &AuthContext,
        resource_tenant: &str,
    ) -> Result<(), AuthError> {
        // Enforce tenant isolation
        if auth.tenant_id != resource_tenant && !auth.permissions.contains(&Permission::SystemAdmin) {
            return Err(AuthError::TenantIsolationViolation);
        }

        Ok(())
    }
}

// Usage in checkpointer
impl SecureCheckpointer {
    pub async fn save(&self, auth: AuthContext, checkpoint: &Checkpoint) -> Result<()> {
        // Check permissions
        self.authz.check_permission(&auth, Permission::CheckpointCreate)?;

        // Enforce tenant isolation
        self.authz.check_resource_access(&auth, &checkpoint.tenant_id)?;

        // Audit log
        self.audit_logger.log(AuditEvent {
            user_id: auth.user_id,
            tenant_id: auth.tenant_id,
            action: "checkpoint.create",
            resource_id: checkpoint.id.clone(),
            timestamp: Utc::now(),
            success: true,
        }).await;

        // Proceed with save
        self.inner.save(checkpoint).await
    }
}
```

### Audit Logging
```rust
// src/auth/audit.rs

#[derive(Debug, Serialize)]
pub struct AuditEvent {
    pub user_id: String,
    pub tenant_id: String,
    pub action: String,
    pub resource_id: String,
    pub timestamp: DateTime<Utc>,
    pub success: bool,
    pub metadata: Option<Value>,
}

pub struct AuditLogger {
    writer: Arc<Mutex<File>>,
}

impl AuditLogger {
    pub async fn log(&self, event: AuditEvent) -> Result<()> {
        let json = serde_json::to_string(&event)?;
        let mut writer = self.writer.lock().await;
        writeln!(writer, "{}", json)?;
        writer.flush()?;
        Ok(())
    }
}
```

### Rate Limiting
```rust
// src/auth/rate_limit.rs

use tower_governor::{Governor, GovernorConfig};

pub fn rate_limit_middleware() -> Governor {
    let config = GovernorConfig::default()
        .per_second(10)     // 10 requests per second
        .burst_size(20);    // Allow bursts up to 20

    Governor::new(config)
}
```

## ‚ö†Ô∏è Security Best Practices

### Password/Key Management
- ‚úÖ **Argon2 for password hashing** - NEVER store plaintext
- ‚úÖ **Secure random for API keys** - Cryptographically secure
- ‚úÖ **Key rotation schedule** - Regular refresh
- ‚úÖ **Secure storage** - Use secrets manager

### Token Security
- ‚úÖ **Short JWT expiry** - 15 minutes for access tokens
- ‚úÖ **Refresh tokens** - Long-lived but revocable
- ‚úÖ **Token blacklist** - Revoke compromised tokens
- ‚úÖ **Secure transmission** - HTTPS only

### Defense in Depth
1. **Rate limiting** - Prevent brute force
2. **IP allowlisting** - Network-level security
3. **CORS configuration** - Prevent XSS
4. **Security headers** - CSP, HSTS, etc.
5. **Input validation** - Prevent injection
6. **Audit everything** - Complete trail

## üìä Default Roles and Permissions

### Admin Role
- All permissions
- Cross-tenant access
- User management
- System configuration

### User Role
- CheckpointCreate, CheckpointRead, CheckpointUpdate
- GraphExecute, GraphRead
- Own tenant only

### ReadOnly Role
- CheckpointRead
- GraphRead
- Own tenant only

### Service Role
- Specific API permissions
- Programmatic access only
- No UI access

## üß™ Testing Requirements

### Security Tests
```rust
#[test]
async fn test_unauthenticated_access_denied() {
    // Make request without auth
    // Verify 401 Unauthorized
}

#[test]
async fn test_invalid_token_rejected() {
    // Use expired/invalid JWT
    // Verify authentication fails
}

#[test]
async fn test_tenant_isolation() {
    // Try to access other tenant's data
    // Verify access denied
}

#[test]
async fn test_permission_enforcement() {
    // Try operation without permission
    // Verify 403 Forbidden
}

#[test]
async fn test_audit_logging() {
    // Perform operations
    // Verify audit events logged
}
```

## üìÖ Implementation Timeline
- **Day 1-2**: Write comprehensive security tests
- **Day 3-4**: Implement authentication middleware
- **Day 5-6**: Implement authorization system
- **Day 7-8**: Add audit logging
- **Day 9-10**: Rate limiting and security headers
- **Day 11-12**: Testing and security audit
- **Day 13-14**: Documentation and deployment guide

## üö® Deployment Requirements

### Environment Variables
```bash
JWT_SECRET=<strong-secret>
API_KEY_SALT=<random-salt>
AUDIT_LOG_PATH=/var/log/langgraph/audit.log
RATE_LIMIT_PER_SECOND=10
IP_ALLOWLIST=192.168.1.0/24,10.0.0.0/8
```

### Initial Setup
1. Generate strong JWT secret
2. Create initial admin user
3. Generate service API keys
4. Configure rate limits
5. Set up audit log rotation
6. Test authentication flow

## üìù Future Enhancements
- OAuth2/OIDC support
- Multi-factor authentication (MFA)
- Biometric authentication
- Certificate-based auth (mTLS)
- Dynamic permission policies
- Attribute-based access control (ABAC)
- Single Sign-On (SSO)

## üî¥ BLOCKER STATUS
**This MUST be implemented before ANY multi-tenant or production deployment.**